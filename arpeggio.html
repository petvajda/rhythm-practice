<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solfege Scale Renderer</title>
    <script src="https://cdn.jsdelivr.net/npm/abcjs@6.2.3/dist/abcjs-basic-min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
            text-align: center;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1em;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            margin-bottom: 15px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 600;
        }
        
        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s;
            background: white;
        }
        
        select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 30px;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .scale-info {
            background: #f0f7ff;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
            display: none;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        #notation {
            margin-top: 0;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 8px;
            border: 2px solid #eee;
            height: 250px;
            overflow: hidden;
        }
        
        #notation .abcjs-title {
            text-align: center;
            font-size: 14px !important;
        }
        
        .playback-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
            justify-content: center;
        }
        
        .playback-controls button {
            padding: 10px 24px;
            width: auto;
            font-size: 18px;
        }
        
        .metronome-control {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            margin-bottom: 12px;
        }
        
        .metronome-control label {
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .metronome-control input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .abc-section {
            margin-top: 20px;
        }
        
        .abc-header {
            background: #667eea;
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s;
        }
        
        .abc-header:hover {
            background: #5568d3;
        }
        
        .abc-header .arrow {
            transition: transform 0.3s;
        }
        
        .abc-header .arrow.open {
            transform: rotate(180deg);
        }
        
        .abc-content {
            display: none;
            margin-top: 10px;
        }
        
        .abc-content.open {
            display: block;
        }
        
        #abc-output {
            margin-top: 0;
            padding: 20px;
            background: #2d2d2d;
            color: #f8f8f2;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            white-space: pre;
            overflow-x: auto;
            border: 2px solid #555;
            min-height: 150px;
            width: 100%;
            resize: vertical;
        }
        
        #abc-output:focus {
            outline: none;
            border-color: #667eea;
            background: #333;
        }
        
        .update-btn {
            margin-top: 10px;
            width: auto;
            padding: 10px 24px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ Arpeggio Exercise Generator</h1>
        
        <div class="controls">
            <div class="control-group">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label for="clef-select" style="margin: 0; min-width: 100px;">Select Clef:</label>
                    <select id="clef-select" style="flex: 1;">
                        <option value="bass">Bass Clef</option>
                        <option value="treble">Treble Clef</option>
                    </select>
                </div>
            </div>
            
            <div class="control-group" style="grid-column: span 2;">
                <button onclick="generateRandomExercise()" style="width: 100%; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);">
                    üé≤ Generate Random Exercise
                </button>
            </div>
            
            <div class="control-group full-width">
                <div id="notation"></div>
            </div>
            
            <div class="control-group full-width">
                <div style="display: flex; gap: 10px; align-items: center; justify-content: center;">
                    <label style="margin: 0; display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="metronome-toggle" checked style="width: 20px; height: 20px; cursor: pointer;">
                        <span>üéµ Metronome</span>
                    </label>
                    <button onclick="playScale()" style="background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); padding: 10px 24px; font-size: 16px;">
                        ‚ñ∂Ô∏è Play
                    </button>
                    <button onclick="stopScale()" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); padding: 10px 24px; font-size: 16px;">
                        ‚èπÔ∏è Stop
                    </button>
                </div>
            </div>
            
            <div class="control-group full-width">
                <label for="tempo-slider">Tempo: <span id="tempo-value">80</span> BPM</label>
                <input type="range" id="tempo-slider" min="50" max="180" value="80" 
                       oninput="document.getElementById('tempo-value').textContent = this.value"
                       style="width: 100%; cursor: pointer;">
            </div>
            
            <div class="control-group full-width" style="text-align: center; margin: 12px 0;">
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div style="flex: 1; height: 2px; background: linear-gradient(to right, transparent, #ddd, transparent);"></div>
                    <span style="color: #999; font-weight: 600; font-size: 14px;">OR CREATE YOUR OWN</span>
                    <div style="flex: 1; height: 2px; background: linear-gradient(to left, transparent, #ddd, transparent);"></div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="base-note-select">Key (Base Note):</label>
                <select id="base-note-select">
                    <option value="C">C</option>
                    <option value="D">D</option>
                    <option value="E">E</option>
                    <option value="F">F</option>
                    <option value="G">G</option>
                    <option value="A">A</option>
                    <option value="B">B</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="accidental-select">Accidental:</label>
                <select id="accidental-select">
                    <option value="">None (Natural)</option>
                    <option value="b">‚ô≠ (Flat)</option>
                    <option value="#">‚ôØ (Sharp)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="scale-select">Scale Type:</label>
                <select id="scale-select">
                    <option value="major">Major</option>
                    <option value="melodic">Melodic Minor</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="pattern-select">16th Note Pattern:</label>
                <select id="pattern-select">
                    <option value="pattern1">Pattern 1: 8 16 16</option>
                    <option value="pattern2">Pattern 2: 16 16 8</option>
                    <option value="pattern3">Pattern 3: 16 8 16</option>
                    <option value="pattern4">Pattern 4: R 16 16 16</option>
                    <option value="pattern5">Pattern 5: 16 16 16 16</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="direction-select">Direction:</label>
                <select id="direction-select">
                    <option value="ascending">Ascending (Root ‚Üí 3rd ‚Üí 5th)</option>
                    <option value="descending">Descending (5th ‚Üí 3rd ‚Üí Root)</option>
                    <option value="alternate-asc-desc">Alternate Asc/Desc (Root‚Üí3rd‚Üí5th, then 5th‚Üí3rd‚ÜíRoot)</option>
                    <option value="alternate-desc-asc">Alternate Desc/Asc (5th‚Üí3rd‚ÜíRoot, then Root‚Üí3rd‚Üí5th)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label style="visibility: hidden;">Randomise</label>
                <button onclick="randomiseRhythmPattern()" style="width: 100%; background: linear-gradient(135deg, #ec4899 0%, #db2777 100%); padding: 10px 24px; margin: 0;">
                    üé≤ Randomise Rhythm Pattern
                </button>
            </div>
        </div>
        
        <button onclick="generateArpeggio()" style="width: 100%; margin-bottom: 20px;">
            üéº Generate Arpeggio Exercise
        </button>
        
        <button onclick="downloadMusicXML()" style="width: 100%; margin-bottom: 20px; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);">
            üì• Download MusicXML
        </button>
        
        <div class="abc-section">
            <div class="abc-header" onclick="toggleABC()">
                <span>ABC Notation (Editable)</span>
                <span class="arrow" id="abc-arrow">‚ñº</span>
            </div>
            <div class="abc-content" id="abc-content">
                <textarea id="abc-output" spellcheck="false"></textarea>
                <button onclick="renderFromABC()" class="update-btn">
                    üîÑ Update from ABC
                </button>
            </div>
        </div>
    </div>

    <script>
        // Solfege Library
        var MODE_NAMES = [
            ["I", "Ionian"],
            ["II", "Dorian"],
            ["III", "Phrygian"],
            ["IV", "Lydian"],
            ["V", "Mixolydian"],
            ["VI", "Aeolian"],
            ["VII", "Locrian"]
        ];

        var CHORD_NAMES = [
            ["I", "maj7"],
            ["II", "m7"],
            ["III", "m7"],
            ["IV", "maj7"],
            ["V", "7"],
            ["VI", "m7"],
            ["VII", "m7b5"]
        ];

        var CMajScale = ["C", "D", "E", "F", "G", "A", "B"];
        var flatKeys = ["F", "Bb", "Eb", "Ab", "Db", "Gb", "Cb"];
        var flatNotes = CMajScale.map(x =>
            CMajScale[(6 + (3 * CMajScale.indexOf(x))) % (CMajScale.length)]);
        var sharpKeys = ["G", "D", "A", "E", "B", "F#", "C#"];
        var sharpNotes = CMajScale.map(x =>
            CMajScale[(3 + (4 * CMajScale.indexOf(x))) % (CMajScale.length)]);

        class SolfegeBase {
            constructor(majorBase, mode) {
                if (mode <= 0 || mode > 7 || !Number.isInteger(mode)) {
                    throw new Error("Mode not supported " + mode);
                }
                this.majorBase = majorBase;
            }
            
            toString() {
                return this.name + ': ' + this.notes.join(' ');
            }
        }

        class MajorScale extends SolfegeBase {
            constructor(majorBase, mode) {
                super(majorBase, mode);
                this.mode = MODE_NAMES[mode - 1][0];
                this.notes = CMajScale.slice();
                var mod = "";
                var start = 0;
                var modNotes = [""];
                
                if (flatKeys.indexOf(this.majorBase) >= 0) {
                    start = flatKeys.indexOf(this.majorBase);
                    mod = "b";
                    modNotes = flatNotes;
                } else if (sharpKeys.indexOf(this.majorBase) >= 0) {
                    start = sharpKeys.indexOf(this.majorBase);
                    mod = "#";
                    modNotes = sharpNotes;
                } else if (!(CMajScale.indexOf(this.majorBase) >= 0)) {
                    throw new Error("majorBase note not supported " + majorBase);
                }

                if (mod != "") {
                    for (var i = 0; i <= start; i++) {
                        let noteIndex = this.notes.indexOf(modNotes[i]);
                        this.notes[noteIndex] = this.notes[noteIndex] + mod;
                    }
                    let b = this.notes.indexOf(this.majorBase);
                    this.notes = this.notes.slice(b).concat(this.notes.slice(0, b));
                }
                this.notes = this.notes.slice(mode - 1).
                    concat(this.notes.slice(0, mode - 1));
                this.name = this.notes[0] + " " + MODE_NAMES[mode - 1][1];
            }
        }

        class MelodicMinorScale extends MajorScale {
            constructor(minorBase, mode) {
                super(minorBase, mode);
                // Flatten the 3rd note (index 2) for melodic minor
                if (this.notes[2].includes("#")) {
                    this.notes[2] = this.notes[2].replace('#', "");
                } else if (!this.notes[2].includes("b")) {
                    this.notes[2] = this.notes[2] + "b";
                }
                // Update the name to reflect melodic minor
                this.name = this.notes[0] + " Melodic Minor";
            }
        }

        class Chord extends SolfegeBase {
            constructor(majorBase, mode) {
                super(majorBase, mode);
                this.mode = CHORD_NAMES[mode - 1][0];
                this.notes = [];
                var baseScale = new MajorScale(majorBase, 1);
                for (var i = 0; i < 4; i++) {
                    this.notes[i] = baseScale.notes[(mode - 1 + i * 2) % 7];
                }
                this.name = this.notes[0] + CHORD_NAMES[mode - 1][1];
            }
        }

        // Convert solfege notes (e.g., ["A", "B", "C#"]) to ABC notation (e.g., ["A,", "B,", "^C"])
        function convertToABCNotation(notes, startingNote, clef = 'treble') {
            const result = [];
            const noteOrder = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
            
            // Define starting octaves for each key in treble clef
            const trebleOctaves = {
                'C': '',      // C (middle)
                'Db': '',     // Db (middle)
                'D': '',      // D (middle)
                'Eb': '',     // Eb (middle)
                'E': '',      // E (middle)
                'F': '',      // F (middle)
                'F#': '',     // F# (middle)
                'Gb': ',',    // Gb (lower)
                'G': '',      // G (middle)
                'Ab': '',     // Ab (middle)
                'A': ',',     // A (lower)
                'Bb': ',',    // Bb (lower)
                'B': ',',     // B (lower)
            };
            
            // Bass clef: one octave lower (add one more comma)
            const bassOctaves = {
                'C': ',',     // C, (lower)
                'Db': ',',    // Db, (lower)
                'D': ',',     // D, (lower)
                'Eb': ',',    // Eb, (lower)
                'E': ',',     // E, (lower)
                'F': ',',     // F, (lower)
                'F#': ',',    // F#, (lower)
                'Gb': ',,',   // Gb,, (even lower)
                'G': ',',     // G, (lower)
                'Ab': ',',    // Ab, (lower)
                'A': ',,',    // A,, (even lower)
                'Bb': ',,',   // Bb,, (even lower)
                'B': ',,',    // B,, (even lower)
            };
            
            let startBase = startingNote[0];
            let startIndex = noteOrder.indexOf(startBase);
            let startingOctaves = clef === 'bass' ? bassOctaves : trebleOctaves;
            let octaveSuffix = startingOctaves[startingNote] || '';
            
            // Track current octave
            let currentOctave = octaveSuffix;
            
            for (let i = 0; i < notes.length; i++) {
                let note = notes[i];
                let baseNote = note[0];
                let accidental = note.slice(1); // # or b or empty
                let currentIndex = noteOrder.indexOf(baseNote);
                
                if (i === 0) {
                    // First note: use starting octave
                    let abcNote = baseNote;
                    if (accidental === '#') {
                        abcNote = '^' + abcNote;
                    } else if (accidental === 'b') {
                        abcNote = '_' + abcNote;
                    }
                    result.push(abcNote + currentOctave);
                } else {
                    // Check if we need to change octave
                    let prevIndex = noteOrder.indexOf(notes[i-1][0]);
                    
                    if (currentIndex <= prevIndex) {
                        // Wrapped to next octave
                        if (currentOctave === ',,') {
                            currentOctave = ','; // From even lower to lower
                        } else if (currentOctave === ',') {
                            currentOctave = ''; // From lower to middle
                        } else if (currentOctave === '') {
                            currentOctave = 'upper'; // From middle to upper
                        }
                    }
                    
                    // Format note
                    let abcNote = baseNote;
                    if (currentOctave === 'upper') {
                        abcNote = baseNote.toLowerCase();
                    }
                    
                    if (accidental === '#') {
                        abcNote = '^' + abcNote;
                    } else if (accidental === 'b') {
                        abcNote = '_' + abcNote;
                    }
                    
                    if (currentOctave === ',') {
                        abcNote += ',';
                    } else if (currentOctave === ',,') {
                        abcNote += ',,';
                    }
                    
                    result.push(abcNote);
                }
            }
            
            return result;
        }

        // Global variables for audio playback
        let currentAbc = "";
        let synthControl = null;
        let audioContext = null;
        let isPlaying = false;
        let scheduledSources = [];
        
        // Initialize audio context
        function getAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioContext;
        }
        
        // Note frequency mapping (A4 = 440Hz)
        const noteFrequencies = {
            'C': 261.63, 'D': 293.66, 'E': 329.63, 'F': 349.23,
            'G': 392.00, 'A': 440.00, 'B': 493.88
        };
        
        // Play metronome click
        function playMetronomeClick(time, strong = false) {
            const ctx = getAudioContext();
            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();
            
            oscillator.frequency.value = strong ? 1200 : 800;
            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);
            
            gainNode.gain.setValueAtTime(0.6, time);
            gainNode.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
            
            oscillator.start(time);
            oscillator.stop(time + 0.1);
            
            scheduledSources.push(oscillator);
        }
        
        // Play a note with piano-like sound
        function playNote(frequency, duration, time) {
            const ctx = getAudioContext();
            
            // Create oscillators for piano-like timbre
            const osc1 = ctx.createOscillator();
            const osc2 = ctx.createOscillator();
            const osc3 = ctx.createOscillator();
            
            osc1.type = 'triangle';
            osc2.type = 'sine';
            osc3.type = 'sine';
            
            osc1.frequency.value = frequency;
            osc2.frequency.value = frequency * 2;
            osc3.frequency.value = frequency * 3;
            
            const gain1 = ctx.createGain();
            const gain2 = ctx.createGain();
            const gain3 = ctx.createGain();
            const masterGain = ctx.createGain();
            
            gain1.gain.value = 0.6;
            gain2.gain.value = 0.25;
            gain3.gain.value = 0.15;
            
            osc1.connect(gain1);
            osc2.connect(gain2);
            osc3.connect(gain3);
            
            gain1.connect(masterGain);
            gain2.connect(masterGain);
            gain3.connect(masterGain);
            masterGain.connect(ctx.destination);
            
            // Piano envelope
            masterGain.gain.setValueAtTime(0, time);
            masterGain.gain.linearRampToValueAtTime(0.4, time + 0.02);
            masterGain.gain.exponentialRampToValueAtTime(0.2, time + duration * 0.3);
            masterGain.gain.exponentialRampToValueAtTime(0.01, time + duration);
            
            osc1.start(time);
            osc1.stop(time + duration);
            osc2.start(time);
            osc2.stop(time + duration);
            osc3.start(time);
            osc3.stop(time + duration);
            
            scheduledSources.push(osc1, osc2, osc3);
        }
        
        // Parse ABC note to frequency
        function parseNoteToFrequency(abcNote) {
            let baseNote = abcNote.replace(/[^A-Ga-g]/g, '')[0];
            if (!baseNote) return 0;
            
            baseNote = baseNote.toUpperCase();
            let frequency = noteFrequencies[baseNote];
            
            if (abcNote.includes('^')) frequency *= Math.pow(2, 1/12);
            if (abcNote.includes('_')) frequency /= Math.pow(2, 1/12);
            
            const commas = (abcNote.match(/,/g) || []).length;
            const apostrophes = (abcNote.match(/'/g) || []).length;
            
            if (commas > 0) frequency /= Math.pow(2, commas);
            if (/[a-g]/.test(abcNote)) frequency *= 2;
            if (apostrophes > 0) frequency *= Math.pow(2, apostrophes);
            
            return frequency;
        }
        
        // Schedule all audio (count-in + exercise)
        function scheduleAudio(tempo, metronomeEnabled) {
            const ctx = getAudioContext();
            const startTime = ctx.currentTime + 0.2;
            const beatDuration = 60 / tempo;
            const sixteenthDuration = beatDuration / 4;
            
            let currentTime = startTime;
            
            // 1-bar (4 beats) count-in with metronome
            if (metronomeEnabled) {
                for (let beat = 0; beat < 4; beat++) {
                    playMetronomeClick(currentTime, beat === 0);
                    currentTime += beatDuration;
                }
            } else {
                currentTime = startTime;
            }
            
            const exerciseStartTime = currentTime;
            
            // Schedule metronome clicks for the entire exercise (4 bars = 16 beats)
            if (metronomeEnabled) {
                for (let beat = 0; beat < 16; beat++) {
                    const beatTime = exerciseStartTime + (beat * beatDuration);
                    playMetronomeClick(beatTime, beat % 4 === 0);
                }
            }
            
            // Parse and schedule the exercise notes from ALL lines
            const lines = currentAbc.split('\n');
            const noteLines = lines.filter(line => 
                !line.startsWith('X:') && 
                !line.startsWith('T:') && 
                !line.startsWith('M:') && 
                !line.startsWith('L:') && 
                !line.startsWith('Q:') && 
                !line.startsWith('K:') &&
                line.trim().length > 0
            );
            
            currentTime = exerciseStartTime;
            
            // Process each line of notation
            noteLines.forEach(noteLine => {
                const tokens = noteLine.replace(/\|/g, ' ').trim().split(/\s+/);
                
                tokens.forEach(token => {
                    let i = 0;
                    
                    // Handle rest at start of token
                    if (token[0] === 'z') {
                        let restDur = 1;
                        i = 1;
                        // Check if there's a number after z
                        if (i < token.length && /\d/.test(token[i])) {
                            restDur = parseInt(token[i]);
                            i++;
                        }
                        currentTime += sixteenthDuration * restDur;
                    }
                    
                    // Parse notes
                    while (i < token.length) {
                        let noteStr = '';
                        let duration = 1;
                        
                        // Collect accidental
                        if (token[i] === '^' || token[i] === '_') {
                            noteStr += token[i];
                            i++;
                        }
                        
                        // Collect note letter
                        if (i < token.length && /[A-Ga-g]/.test(token[i])) {
                            noteStr += token[i];
                            i++;
                            
                            // Collect octave markers
                            while (i < token.length && (token[i] === ',' || token[i] === "'")) {
                                noteStr += token[i];
                                i++;
                            }
                            
                            // Collect duration
                            if (i < token.length && /\d/.test(token[i])) {
                                duration = parseInt(token[i]);
                                i++;
                            }
                            
                            // Play the note
                            if (noteStr.length > 0) {
                                const freq = parseNoteToFrequency(noteStr);
                                if (freq > 0) {
                                    playNote(freq, sixteenthDuration * duration * 0.95, currentTime);
                                }
                                currentTime += sixteenthDuration * duration;
                            }
                        } else {
                            i++;
                        }
                    }
                });
            });
            
            return currentTime - startTime;
        }

        // Generate arpeggio pattern from scale chords
        function generateArpeggioPattern(key, scaleType, clef, patternType, direction) {
            // Generate the scale first to get correct notes
            let scale;
            if (scaleType === 'melodic') {
                scale = new MelodicMinorScale(key, 1);
            } else {
                scale = new MajorScale(key, 1);
            }
            
            // Get the scale notes
            const scaleNotes = scale.notes;
            
            // Generate all 7 chords based on the scale
            const chords = [];
            
            for (let i = 0; i < 7; i++) {
                // Build triad: root, third (skip 1), fifth (skip 2)
                const triad = [
                    scaleNotes[i],
                    scaleNotes[(i + 2) % 7],
                    scaleNotes[(i + 4) % 7]
                ];
                chords.push(triad);
            }
            
            const noteOrder = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
            const abcChords = [];
            
            // Define instrument ranges:
            // Bass clef: E,, to e (E two octaves below middle C to e above middle C)
            // Treble clef: C to c'' (middle C to c two octaves above)
            
            const rootNote = scaleNotes[0][0];
            const rootIndex = noteOrder.indexOf(rootNote);
            
            let startOctave;
            if (clef === 'bass') {
                // Bass clef range: E,, to e
                // Start mapping:
                // E, F, G, A, B ‚Üí start with ,,
                // C, D ‚Üí start with ,
                if (rootIndex >= 2) { // E, F, G, A, B (indices 2-6)
                    startOctave = ',,';
                } else { // C, D (indices 0-1)
                    startOctave = ',';
                }
            } else {
                // Treble clef range: C to c''
                // Start mapping:
                // C, D, E, F ‚Üí start with '' (no comma, middle octave)
                // G, A, B ‚Üí start with ,
                if (rootIndex <= 3) { // C, D, E, F (indices 0-3)
                    startOctave = '';
                } else { // G, A, B (indices 4-6)
                    startOctave = ',';
                }
            }
            
            // Track octave for each note position as we build the ascending line
            let lastNoteIndex = rootIndex;
            let currentOctave = startOctave;
            
            for (let i = 0; i < chords.length; i++) {
                const triad = chords[i];
                const abcTriad = [];
                
                // Check if root note wrapped around (needs octave bump)
                const rootIdx = noteOrder.indexOf(triad[0][0]);
                if (rootIdx < lastNoteIndex) {
                    // Wrapped around, go up an octave
                    if (currentOctave === ',,') {
                        currentOctave = ',';
                    } else if (currentOctave === ',') {
                        currentOctave = '';
                    } else if (currentOctave === '') {
                        currentOctave = 'upper';
                    } else if (currentOctave === 'upper') {
                        currentOctave = 'upper2';
                    }
                }
                lastNoteIndex = rootIdx;
                
                // Now process each note in the triad
                let triadOctave = currentOctave;
                let lastTriadNoteIndex = rootIdx;
                
                for (let j = 0; j < 3; j++) {
                    const note = triad[j];
                    const baseNote = note[0];
                    const accidental = note.slice(1);
                    const noteIndex = noteOrder.indexOf(baseNote);
                    
                    // Check if this note wrapped within the triad
                    if (j > 0 && noteIndex < lastTriadNoteIndex) {
                        if (triadOctave === ',,') {
                            triadOctave = ',';
                        } else if (triadOctave === ',') {
                            triadOctave = '';
                        } else if (triadOctave === '') {
                            triadOctave = 'upper';
                        } else if (triadOctave === 'upper') {
                            triadOctave = 'upper2';
                        }
                    }
                    lastTriadNoteIndex = noteIndex;
                    
                    let abcNote = baseNote;
                    if (accidental === '#') {
                        abcNote = '^' + abcNote;
                    } else if (accidental === 'b') {
                        abcNote = '_' + abcNote;
                    }
                    
                    // Apply octave
                    if (triadOctave === ',,') {
                        abcTriad.push(abcNote + ',,');
                    } else if (triadOctave === ',') {
                        abcTriad.push(abcNote + ',');
                    } else if (triadOctave === '') {
                        abcTriad.push(abcNote);
                    } else if (triadOctave === 'upper') {
                        abcTriad.push(abcNote.toLowerCase());
                    } else if (triadOctave === 'upper2') {
                        abcTriad.push(abcNote.toLowerCase() + "'");
                    }
                }
                
                abcChords.push(abcTriad);
            }
            
            // Build arpeggio pattern based on selected pattern and direction
            const bar1 = [];
            const bar2 = [];
            const bar3 = []; // Coming back
            const bar4 = []; // Coming back
            
            for (let i = 0; i < 7; i++) {
                const chord = abcChords[i];
                let pattern;
                
                // Determine direction for this chord based on overall direction setting
                let isAscending;
                if (direction === 'ascending') {
                    isAscending = true;
                } else if (direction === 'descending') {
                    isAscending = false;
                } else if (direction === 'alternate-asc-desc') {
                    // Alternate: odd chords ascending, even chords descending
                    isAscending = (i % 2 === 0);
                } else if (direction === 'alternate-desc-asc') {
                    // Alternate: odd chords descending, even chords ascending
                    isAscending = (i % 2 === 1);
                }
                
                // Get notes in the right order based on direction and pattern
                let note1, note2, note3, note4;
                if (patternType === 'pattern5') {
                    // Pattern 5 uses 4 notes
                    if (isAscending) {
                        // Root, 3rd, 5th, Root (ascending: start and end with root)
                        note1 = chord[0];
                        note2 = chord[1];
                        note3 = chord[2];
                        note4 = chord[0]; // Same as first note
                    } else {
                        // 5th, 3rd, Root, 5th (descending: start and end with 5th)
                        note1 = chord[2]; // 5th
                        note2 = chord[1]; // 3rd
                        note3 = chord[0]; // Root
                        note4 = chord[2]; // 5th (same as first note)
                    }
                    pattern = `${note1}${note2}${note3}${note4}`;
                } else {
                    // Patterns 1-4 use 3 notes
                    if (isAscending) {
                        // Root, 3rd, 5th (ascending)
                        note1 = chord[0];
                        note2 = chord[1];
                        note3 = chord[2];
                    } else {
                        // 5th, 3rd, Root (descending)
                        note1 = chord[2];
                        note2 = chord[1];
                        note3 = chord[0];
                    }
                    
                    if (patternType === 'pattern1') {
                        // Pattern 1: Note1(2) Note2 Note3
                        pattern = `${note1}2${note2}${note3}`;
                    } else if (patternType === 'pattern2') {
                        // Pattern 2: Note1 Note2 Note3(2)
                        pattern = `${note1}${note2}${note3}2`;
                    } else if (patternType === 'pattern3') {
                        // Pattern 3: Note1 Note2(2) Note3
                        pattern = `${note1}${note2}2${note3}`;
                    } else if (patternType === 'pattern4') {
                        // Pattern 4: Rest Note1 Note2 Note3
                        pattern = `z${note1}${note2}${note3}`;
                    }
                }
                
                if (i < 4) {
                    bar1.push(pattern);
                } else if (i < 7) {
                    bar2.push(pattern);
                }
            }
            
            // Add the first chord again, one octave higher, as the ending of bar 2
            const firstChord = chords[0];
            const firstChordAbcHigher = [];
            
            // Calculate the ending octave based on the last note of bar 2
            // We want to go exactly one octave higher than the first chord
            const firstChordOctave = abcChords[0][0].match(/,+|'+/)?.[0] || '';
            let endingOctave;
            
            if (firstChordOctave === ',,') {
                endingOctave = ',';
            } else if (firstChordOctave === ',') {
                endingOctave = '';
            } else if (firstChordOctave === '') {
                endingOctave = 'upper';
            } else if (firstChordOctave === 'upper') {
                endingOctave = 'upper2';
            } else {
                endingOctave = 'upper';
            }
            
            // Track octave within the ending triad
            let endingTriadOctave = endingOctave;
            let lastEndingNoteIndex = noteOrder.indexOf(firstChord[0][0]);
            
            for (let j = 0; j < 3; j++) {
                const note = firstChord[j];
                const baseNote = note[0];
                const accidental = note.slice(1);
                const noteIndex = noteOrder.indexOf(baseNote);
                
                // Check if this note wrapped within the triad
                if (j > 0 && noteIndex < lastEndingNoteIndex) {
                    if (endingTriadOctave === ',,') {
                        endingTriadOctave = ',';
                    } else if (endingTriadOctave === ',') {
                        endingTriadOctave = '';
                    } else if (endingTriadOctave === '') {
                        endingTriadOctave = 'upper';
                    } else if (endingTriadOctave === 'upper') {
                        endingTriadOctave = 'upper2';
                    }
                }
                lastEndingNoteIndex = noteIndex;
                
                let abcNote = baseNote;
                if (accidental === '#') {
                    abcNote = '^' + abcNote;
                } else if (accidental === 'b') {
                    abcNote = '_' + abcNote;
                }
                
                // Apply ending octave
                if (endingTriadOctave === ',,') {
                    firstChordAbcHigher.push(abcNote + ',,');
                } else if (endingTriadOctave === ',') {
                    firstChordAbcHigher.push(abcNote + ',');
                } else if (endingTriadOctave === '') {
                    firstChordAbcHigher.push(abcNote);
                } else if (endingTriadOctave === 'upper') {
                    firstChordAbcHigher.push(abcNote.toLowerCase());
                } else if (endingTriadOctave === 'upper2') {
                    firstChordAbcHigher.push(abcNote.toLowerCase() + "'");
                }
            }
            
            // Add ending chord with same pattern and direction logic
            let endingPattern;
            // The 8th chord (index 7) follows the same alternating pattern
            let endingIsAscending;
            if (direction === 'ascending') {
                endingIsAscending = true;
            } else if (direction === 'descending') {
                endingIsAscending = false;
            } else if (direction === 'alternate-asc-desc') {
                // Index 7 is even, so ascending
                endingIsAscending = (7 % 2 === 0);
            } else if (direction === 'alternate-desc-asc') {
                // Index 7 is even, so descending
                endingIsAscending = (7 % 2 === 1);
            }
            
            if (patternType === 'pattern5') {
                // Pattern 5 uses 4 notes
                let endNote1, endNote2, endNote3, endNote4;
                if (endingIsAscending) {
                    // Root, 3rd, 5th, Root (ascending: start and end with root)
                    endNote1 = firstChordAbcHigher[0];
                    endNote2 = firstChordAbcHigher[1];
                    endNote3 = firstChordAbcHigher[2];
                    endNote4 = firstChordAbcHigher[0]; // Same as first note
                } else {
                    // 5th, 3rd, Root, 5th (descending: start and end with 5th)
                    endNote1 = firstChordAbcHigher[2]; // 5th
                    endNote2 = firstChordAbcHigher[1]; // 3rd
                    endNote3 = firstChordAbcHigher[0]; // Root
                    endNote4 = firstChordAbcHigher[2]; // 5th (same as first note)
                }
                endingPattern = `${endNote1}${endNote2}${endNote3}${endNote4}`;
            } else {
                // Patterns 1-4 use 3 notes
                let endNote1, endNote2, endNote3;
                if (endingIsAscending) {
                    // Root, 3rd, 5th (ascending order)
                    endNote1 = firstChordAbcHigher[0];
                    endNote2 = firstChordAbcHigher[1];
                    endNote3 = firstChordAbcHigher[2];
                } else {
                    // 5th, 3rd, Root (descending order)
                    endNote1 = firstChordAbcHigher[2];
                    endNote2 = firstChordAbcHigher[1];
                    endNote3 = firstChordAbcHigher[0];
                }
                
                if (patternType === 'pattern1') {
                    endingPattern = `${endNote1}2${endNote2}${endNote3}`;
                } else if (patternType === 'pattern2') {
                    endingPattern = `${endNote1}${endNote2}${endNote3}2`;
                } else if (patternType === 'pattern3') {
                    endingPattern = `${endNote1}${endNote2}2${endNote3}`;
                } else if (patternType === 'pattern4') {
                    endingPattern = `z${endNote1}${endNote2}${endNote3}`;
                }
            }
            bar2.push(endingPattern);
            
            // Now generate the return journey (bars 3 and 4)
            // Bar 3 starts with the same chord as end of bar 2 (the higher octave first chord)
            // Then continues with chords in reverse: 6, 5, 4, 3
            // Bar 4 has: 2, 1, 0 (back to start)
            
            // First, add the higher octave chord again at start of bar 3
            bar3.push(endingPattern);
            
            // Then add chords 6, 5, 4 to bar 3
            for (let i = 6; i >= 4; i--) {
                const chord = abcChords[i];
                let pattern;
                
                // Determine direction for this chord
                let isAscending;
                if (direction === 'ascending') {
                    isAscending = true;
                } else if (direction === 'descending') {
                    isAscending = false;
                } else if (direction === 'alternate-asc-desc') {
                    isAscending = (i % 2 === 0);
                } else if (direction === 'alternate-desc-asc') {
                    isAscending = (i % 2 === 1);
                }
                
                // Get notes in the right order
                let note1, note2, note3, note4;
                if (patternType === 'pattern5') {
                    if (isAscending) {
                        note1 = chord[0];
                        note2 = chord[1];
                        note3 = chord[2];
                        note4 = chord[0];
                    } else {
                        note1 = chord[2];
                        note2 = chord[1];
                        note3 = chord[0];
                        note4 = chord[2];
                    }
                    pattern = `${note1}${note2}${note3}${note4}`;
                } else {
                    if (isAscending) {
                        note1 = chord[0];
                        note2 = chord[1];
                        note3 = chord[2];
                    } else {
                        note1 = chord[2];
                        note2 = chord[1];
                        note3 = chord[0];
                    }
                    
                    if (patternType === 'pattern1') {
                        pattern = `${note1}2${note2}${note3}`;
                    } else if (patternType === 'pattern2') {
                        pattern = `${note1}${note2}${note3}2`;
                    } else if (patternType === 'pattern3') {
                        pattern = `${note1}${note2}2${note3}`;
                    } else if (patternType === 'pattern4') {
                        pattern = `z${note1}${note2}${note3}`;
                    }
                }
                
                bar3.push(pattern);
            }
            
            // Bar 4 has chords 3, 2, 1, 0
            for (let i = 3; i >= 0; i--) {
                const chord = abcChords[i];
                let pattern;
                
                // Determine direction for this chord
                let isAscending;
                if (direction === 'ascending') {
                    isAscending = true;
                } else if (direction === 'descending') {
                    isAscending = false;
                } else if (direction === 'alternate-asc-desc') {
                    isAscending = (i % 2 === 0);
                } else if (direction === 'alternate-desc-asc') {
                    isAscending = (i % 2 === 1);
                }
                
                // Get notes in the right order
                let note1, note2, note3, note4;
                if (patternType === 'pattern5') {
                    if (isAscending) {
                        note1 = chord[0];
                        note2 = chord[1];
                        note3 = chord[2];
                        note4 = chord[0];
                    } else {
                        note1 = chord[2];
                        note2 = chord[1];
                        note3 = chord[0];
                        note4 = chord[2];
                    }
                    pattern = `${note1}${note2}${note3}${note4}`;
                } else {
                    if (isAscending) {
                        note1 = chord[0];
                        note2 = chord[1];
                        note3 = chord[2];
                    } else {
                        note1 = chord[2];
                        note2 = chord[1];
                        note3 = chord[0];
                    }
                    
                    if (patternType === 'pattern1') {
                        pattern = `${note1}2${note2}${note3}`;
                    } else if (patternType === 'pattern2') {
                        pattern = `${note1}${note2}${note3}2`;
                    } else if (patternType === 'pattern3') {
                        pattern = `${note1}${note2}2${note3}`;
                    } else if (patternType === 'pattern4') {
                        pattern = `z${note1}${note2}${note3}`;
                    }
                }
                
                bar4.push(pattern);
            }
            
            // Join patterns into 4 bars
            const bar1Str = bar1.join(' ');
            const bar2Str = bar2.join(' ');
            const bar3Str = bar3.join(' ');
            const bar4Str = bar4.join(' ');
            
            return `${bar1Str} | ${bar2Str} |\n${bar3Str} | ${bar4Str}|`;
        }

        // Render scale or arpeggio
        function renderArpeggio(scale, scaleType, pattern, clef, tempo, direction) {
            try {
                // Get solfege notes from scale
                const solfegeNotes = scale.notes;
                const baseKey = solfegeNotes[0];
                
                // Generate arpeggio pattern
                let abcNotesString;
                if (pattern === 'pattern1' || pattern === 'pattern2' || pattern === 'pattern3' || pattern === 'pattern4' || pattern === 'pattern5') {
                    abcNotesString = generateArpeggioPattern(baseKey, scaleType, clef, pattern, direction);
                }
                
                // Build ABC notation string (no metronome track)
                const abc = [
                    'X:1',
                    `T:${scale.name} (${direction})`,
                    'M:4/4',
                    'L:1/16',
                    `Q:${tempo}`,
                    `K:C clef=${clef}`,
                    abcNotesString
                ].join('\n');
                
                // Display ABC notation in textarea
                document.getElementById('abc-output').value = abc;
                currentAbc = abc;
                
                // Render with abcjs with wrapping for better multi-line layout
                ABCJS.renderAbc('notation', abc, {
                    responsive: 'resize',
                    scale: 0.65,
                    staffwidth: 800,
                    wrap: {
                        minSpacing: 1.8,
                        maxSpacing: 2.7,
                        preferredMeasuresPerLine: 2
                    }
                });
            } catch (error) {
                document.getElementById('notation').innerHTML = 
                    `<p style="color: red; font-weight: bold;">Error: ${error.message}</p>`;
                console.error(error);
            }
        }
        
        function generateRandomExercise() {
            // Random key (base note + accidental combined)
            const keys = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'F#', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
            const randomKey = keys[Math.floor(Math.random() * keys.length)];
            
            // Parse the random key into base note and accidental
            const baseNote = randomKey[0];
            const accidental = randomKey.slice(1);
            document.getElementById('base-note-select').value = baseNote;
            document.getElementById('accidental-select').value = accidental;
            
            // Random scale type
            const scaleTypes = ['major', 'melodic'];
            const randomScale = scaleTypes[Math.floor(Math.random() * scaleTypes.length)];
            document.getElementById('scale-select').value = randomScale;
            
            // Random pattern
            const patterns = ['pattern1', 'pattern2', 'pattern3', 'pattern4', 'pattern5'];
            const randomPattern = patterns[Math.floor(Math.random() * patterns.length)];
            document.getElementById('pattern-select').value = randomPattern;
            
            // Random direction
            const directions = ['ascending', 'descending', 'alternate-asc-desc', 'alternate-desc-asc'];
            const randomDirection = directions[Math.floor(Math.random() * directions.length)];
            document.getElementById('direction-select').value = randomDirection;
            
            // Generate the exercise (keeps current clef and tempo)
            generateArpeggio();
        }
        
        function randomiseRhythmPattern() {
            const baseNote = document.getElementById('base-note-select').value;
            const accidental = document.getElementById('accidental-select').value;
            const key = baseNote + accidental;
            const scaleType = document.getElementById('scale-select').value;
            const clef = document.getElementById('clef-select').value;
            const tempo = parseInt(document.getElementById('tempo-slider').value);
            const direction = document.getElementById('direction-select').value;
            
            let scale;
            if (scaleType === 'major') {
                scale = new MajorScale(key, 1);
                scale.name = key + " Major";
            } else if (scaleType === 'melodic') {
                scale = new MelodicMinorScale(key, 1);
            }
            
            renderArpeggioWithRandomPatterns(scale, scaleType, clef, tempo, direction);
        }
        
        function renderArpeggioWithRandomPatterns(scale, scaleType, clef, tempo, direction) {
            try {
                const solfegeNotes = scale.notes;
                const baseKey = solfegeNotes[0];
                
                // Generate arpeggio pattern with random rhythm patterns for each chord
                const abcNotesString = generateArpeggioPatternRandomRhythm(baseKey, scaleType, clef, direction);
                
                const abc = [
                    'X:1',
                    `T:${scale.name} (${direction}) - Random Patterns`,
                    'M:4/4',
                    'L:1/16',
                    `Q:${tempo}`,
                    `K:C clef=${clef}`,
                    abcNotesString
                ].join('\n');
                
                document.getElementById('abc-output').value = abc;
                currentAbc = abc;
                
                ABCJS.renderAbc('notation', abc, {
                    responsive: 'resize',
                    scale: 0.65,
                    staffwidth: 800,
                    wrap: {
                        minSpacing: 1.8,
                        maxSpacing: 2.7,
                        preferredMeasuresPerLine: 2
                    }
                });
            } catch (error) {
                document.getElementById('notation').innerHTML = 
                    `<p style="color: red; font-weight: bold;">Error: ${error.message}</p>`;
                console.error(error);
            }
        }
        
        function generateArpeggioPatternRandomRhythm(key, scaleType, clef, direction) {
            // Generate the scale first to get correct notes
            let scale;
            if (scaleType === 'melodic') {
                scale = new MelodicMinorScale(key, 1);
            } else {
                scale = new MajorScale(key, 1);
            }
            
            const scaleNotes = scale.notes;
            const chords = [];
            
            for (let i = 0; i < 7; i++) {
                const triad = [
                    scaleNotes[i],
                    scaleNotes[(i + 2) % 7],
                    scaleNotes[(i + 4) % 7]
                ];
                chords.push(triad);
            }
            
            const noteOrder = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
            const abcChords = [];
            
            const rootNote = scaleNotes[0][0];
            const rootIndex = noteOrder.indexOf(rootNote);
            
            let startOctave;
            if (clef === 'bass') {
                if (rootIndex >= 2) {
                    startOctave = ',,';
                } else {
                    startOctave = ',';
                }
            } else {
                if (rootIndex <= 3) {
                    startOctave = '';
                } else {
                    startOctave = ',';
                }
            }
            
            let lastNoteIndex = rootIndex;
            let currentOctave = startOctave;
            
            for (let i = 0; i < chords.length; i++) {
                const triad = chords[i];
                const abcTriad = [];
                
                const rootIdx = noteOrder.indexOf(triad[0][0]);
                if (rootIdx < lastNoteIndex) {
                    if (currentOctave === ',,') {
                        currentOctave = ',';
                    } else if (currentOctave === ',') {
                        currentOctave = '';
                    } else if (currentOctave === '') {
                        currentOctave = 'upper';
                    } else if (currentOctave === 'upper') {
                        currentOctave = 'upper2';
                    }
                }
                lastNoteIndex = rootIdx;
                
                let triadOctave = currentOctave;
                let lastTriadNoteIndex = rootIdx;
                
                for (let j = 0; j < 3; j++) {
                    const note = triad[j];
                    const baseNote = note[0];
                    const accidental = note.slice(1);
                    const noteIndex = noteOrder.indexOf(baseNote);
                    
                    if (j > 0 && noteIndex < lastTriadNoteIndex) {
                        if (triadOctave === ',,') {
                            triadOctave = ',';
                        } else if (triadOctave === ',') {
                            triadOctave = '';
                        } else if (triadOctave === '') {
                            triadOctave = 'upper';
                        } else if (triadOctave === 'upper') {
                            triadOctave = 'upper2';
                        }
                    }
                    lastTriadNoteIndex = noteIndex;
                    
                    let abcNote = baseNote;
                    if (accidental === '#') {
                        abcNote = '^' + abcNote;
                    } else if (accidental === 'b') {
                        abcNote = '_' + abcNote;
                    }
                    
                    if (triadOctave === ',,') {
                        abcTriad.push(abcNote + ',,');
                    } else if (triadOctave === ',') {
                        abcTriad.push(abcNote + ',');
                    } else if (triadOctave === '') {
                        abcTriad.push(abcNote);
                    } else if (triadOctave === 'upper') {
                        abcTriad.push(abcNote.toLowerCase());
                    } else if (triadOctave === 'upper2') {
                        abcTriad.push(abcNote.toLowerCase() + "'");
                    }
                }
                
                abcChords.push(abcTriad);
            }
            
            // Build bars with random patterns for each chord
            const bar1 = [];
            const bar2 = [];
            const bar3 = [];
            const bar4 = [];
            const patterns = ['pattern1', 'pattern2', 'pattern3', 'pattern4', 'pattern5'];
            
            // Going up: chords 0-6 + higher octave chord
            for (let i = 0; i < 7; i++) {
                const chord = abcChords[i];
                const randomPattern = patterns[Math.floor(Math.random() * patterns.length)];
                const pattern = generatePatternForChord(chord, randomPattern, direction, i);
                
                if (i < 4) {
                    bar1.push(pattern);
                } else {
                    bar2.push(pattern);
                }
            }
            
            // Add higher octave ending chord for bar 2
            const firstChord = chords[0];
            const firstChordAbcHigher = calculateHigherOctaveChord(firstChord, abcChords[0], noteOrder);
            const randomEndPattern = patterns[Math.floor(Math.random() * patterns.length)];
            const endPattern = generatePatternForChord(firstChordAbcHigher, randomEndPattern, direction, 7);
            bar2.push(endPattern);
            
            // Coming back down: bar 3 starts with same chord
            bar3.push(endPattern);
            
            // Then chords 6, 5, 4
            for (let i = 6; i >= 4; i--) {
                const chord = abcChords[i];
                const randomPattern = patterns[Math.floor(Math.random() * patterns.length)];
                const pattern = generatePatternForChord(chord, randomPattern, direction, i);
                bar3.push(pattern);
            }
            
            // Bar 4: chords 3, 2, 1, 0
            for (let i = 3; i >= 0; i--) {
                const chord = abcChords[i];
                const randomPattern = patterns[Math.floor(Math.random() * patterns.length)];
                const pattern = generatePatternForChord(chord, randomPattern, direction, i);
                bar4.push(pattern);
            }
            
            const bar1Str = bar1.join(' ');
            const bar2Str = bar2.join(' ');
            const bar3Str = bar3.join(' ');
            const bar4Str = bar4.join(' ');
            
            return `${bar1Str} | ${bar2Str} |\n${bar3Str} | ${bar4Str}|`;
        }
        
        function generatePatternForChord(chord, patternType, direction, chordIndex) {
            let isAscending;
            if (direction === 'ascending') {
                isAscending = true;
            } else if (direction === 'descending') {
                isAscending = false;
            } else if (direction === 'alternate-asc-desc') {
                isAscending = (chordIndex % 2 === 0);
            } else if (direction === 'alternate-desc-asc') {
                isAscending = (chordIndex % 2 === 1);
            }
            
            let note1, note2, note3, note4;
            
            if (patternType === 'pattern5') {
                if (isAscending) {
                    note1 = chord[0];
                    note2 = chord[1];
                    note3 = chord[2];
                    note4 = chord[0];
                } else {
                    note1 = chord[2];
                    note2 = chord[1];
                    note3 = chord[0];
                    note4 = chord[2];
                }
                return `${note1}${note2}${note3}${note4}`;
            } else {
                if (isAscending) {
                    note1 = chord[0];
                    note2 = chord[1];
                    note3 = chord[2];
                } else {
                    note1 = chord[2];
                    note2 = chord[1];
                    note3 = chord[0];
                }
                
                if (patternType === 'pattern1') {
                    return `${note1}2${note2}${note3}`;
                } else if (patternType === 'pattern2') {
                    return `${note1}${note2}${note3}2`;
                } else if (patternType === 'pattern3') {
                    return `${note1}${note2}2${note3}`;
                } else if (patternType === 'pattern4') {
                    return `z${note1}${note2}${note3}`;
                }
            }
        }
        
        function calculateHigherOctaveChord(firstChord, firstChordAbc, noteOrder) {
            const firstChordOctave = firstChordAbc[0].match(/,+|'+/)?.[0] || '';
            let endingOctave;
            
            if (firstChordOctave === ',,') {
                endingOctave = ',';
            } else if (firstChordOctave === ',') {
                endingOctave = '';
            } else if (firstChordOctave === '') {
                endingOctave = 'upper';
            } else if (firstChordOctave === 'upper') {
                endingOctave = 'upper2';
            } else {
                endingOctave = 'upper';
            }
            
            let endingTriadOctave = endingOctave;
            let lastEndingNoteIndex = noteOrder.indexOf(firstChord[0][0]);
            const firstChordAbcHigher = [];
            
            for (let j = 0; j < 3; j++) {
                const note = firstChord[j];
                const baseNote = note[0];
                const accidental = note.slice(1);
                const noteIndex = noteOrder.indexOf(baseNote);
                
                if (j > 0 && noteIndex < lastEndingNoteIndex) {
                    if (endingTriadOctave === ',,') {
                        endingTriadOctave = ',';
                    } else if (endingTriadOctave === ',') {
                        endingTriadOctave = '';
                    } else if (endingTriadOctave === '') {
                        endingTriadOctave = 'upper';
                    } else if (endingTriadOctave === 'upper') {
                        endingTriadOctave = 'upper2';
                    }
                }
                lastEndingNoteIndex = noteIndex;
                
                let abcNote = baseNote;
                if (accidental === '#') {
                    abcNote = '^' + abcNote;
                } else if (accidental === 'b') {
                    abcNote = '_' + abcNote;
                }
                
                if (endingTriadOctave === ',,') {
                    firstChordAbcHigher.push(abcNote + ',,');
                } else if (endingTriadOctave === ',') {
                    firstChordAbcHigher.push(abcNote + ',');
                } else if (endingTriadOctave === '') {
                    firstChordAbcHigher.push(abcNote);
                } else if (endingTriadOctave === 'upper') {
                    firstChordAbcHigher.push(abcNote.toLowerCase());
                } else if (endingTriadOctave === 'upper2') {
                    firstChordAbcHigher.push(abcNote.toLowerCase() + "'");
                }
            }
            
            return firstChordAbcHigher;
        }
        
        function generateArpeggio() {
            const baseNote = document.getElementById('base-note-select').value;
            const accidental = document.getElementById('accidental-select').value;
            const key = baseNote + accidental;
            const scaleType = document.getElementById('scale-select').value;
            const pattern = document.getElementById('pattern-select').value;
            const clef = document.getElementById('clef-select').value;
            const tempo = parseInt(document.getElementById('tempo-slider').value);
            const direction = document.getElementById('direction-select').value;
            
            let scale;
            if (scaleType === 'major') {
                scale = new MajorScale(key, 1); // Mode 1 = Ionian
                scale.name = key + " Major";
            } else if (scaleType === 'melodic') {
                scale = new MelodicMinorScale(key, 1);
            }
            
            renderArpeggio(scale, scaleType, pattern, clef, tempo, direction);
        }
        
        // Render directly from ABC notation textarea
        function renderFromABC() {
            try {
                const abc = document.getElementById('abc-output').value;
                currentAbc = abc;
                
                ABCJS.renderAbc('notation', abc, {
                    responsive: 'resize',
                    scale: 0.65,
                    staffwidth: 800,
                    wrap: {
                        minSpacing: 1.8,
                        maxSpacing: 2.7,
                        preferredMeasuresPerLine: 2
                    }
                });
            } catch (error) {
                document.getElementById('notation').innerHTML = 
                    `<p style="color: red; font-weight: bold;">Error: ${error.message}</p>`;
            }
        }
        
        // Play the scale
        async function playScale() {
            if (!currentAbc) {
                alert("No scale to play!");
                return;
            }
            
            if (isPlaying) {
                return;
            }
            
            try {
                isPlaying = true;
                
                // Stop any currently playing audio
                stopScale();
                
                const tempo = parseInt(document.getElementById('tempo-slider').value);
                const metronomeEnabled = document.getElementById('metronome-toggle').checked;
                
                // Initialize audio context
                getAudioContext();
                
                // Schedule all audio with precise Web Audio timing
                const totalDuration = scheduleAudio(tempo, metronomeEnabled);
                
                // Auto-stop after playback finishes
                setTimeout(() => {
                    isPlaying = false;
                    scheduledSources = [];
                }, totalDuration * 1000 + 500);
                
            } catch (error) {
                console.error("Play error:", error);
                isPlaying = false;
                alert("Error playing: " + error.message);
            }
        }
        
        // Stop playback
        function stopScale() {
            const ctx = getAudioContext();
            const now = ctx.currentTime;
            
            scheduledSources.forEach(source => {
                try {
                    source.stop(now);
                } catch (e) {
                    // Already stopped
                }
            });
            
            scheduledSources = [];
            isPlaying = false;
        }
        
        // Toggle ABC notation section
        function toggleABC() {
            const content = document.getElementById('abc-content');
            const arrow = document.getElementById('abc-arrow');
            content.classList.toggle('open');
            arrow.classList.toggle('open');
        }
        
        // MusicXML Export functionality
        function downloadMusicXML() {
            if (!currentAbc) {
                alert("No exercise to download! Generate one first.");
                return;
            }
            
            const musicXML = abcToMusicXML(currentAbc);
            
            // Create blob and download
            const blob = new Blob([musicXML], { type: 'application/vnd.recordare.musicxml+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'arpeggio-exercise.musicxml';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function abcToMusicXML(abc) {
            // Parse ABC to extract information
            const lines = abc.split('\n');
            let tempo = 80;
            let timeSignature = '4/4';
            let clef = 'bass';
            
            // Extract tempo, time signature, and clef from ABC header
            lines.forEach(line => {
                if (line.startsWith('Q:')) {
                    tempo = parseInt(line.substring(2));
                }
                if (line.startsWith('M:')) {
                    timeSignature = line.substring(2).trim();
                }
                if (line.includes('clef=')) {
                    clef = line.includes('clef=treble') ? 'treble' : 'bass';
                }
            });
            
            // Get note lines
            const noteLines = lines.filter(line => 
                !line.startsWith('X:') && 
                !line.startsWith('T:') && 
                !line.startsWith('M:') && 
                !line.startsWith('L:') && 
                !line.startsWith('Q:') && 
                !line.startsWith('K:') &&
                !line.startsWith('%') &&
                line.trim().length > 0
            );
            
            // Parse notes and create MusicXML measures
            let measuresXML = '';
            let measureNumber = 1;
            
            noteLines.forEach(noteLine => {
                const cleanLine = noteLine.replace(/\|\$/g, '|').replace(/\|\]/g, '|').trim();
                const measures = cleanLine.split('|').filter(m => m.trim().length > 0);
                
                measures.forEach(measure => {
                    measuresXML += generateMeasureXML(measure.trim(), measureNumber, clef, tempo);
                    measureNumber++;
                });
            });
            
            // Build complete MusicXML document
            const musicXML = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="3.1">
  <work>
    <work-title>Arpeggio Exercise</work-title>
  </work>
  <identification>
    <creator type="composer">Arpeggio Exercise Generator</creator>
    <encoding>
      <software>Arpeggio Exercise Generator</software>
      <encoding-date>${new Date().toISOString().split('T')[0]}</encoding-date>
    </encoding>
  </identification>
  <part-list>
    <score-part id="P1">
      <part-name>${clef === 'bass' ? 'Bass' : 'Treble'}</part-name>
      <score-instrument id="P1-I1">
        <instrument-name>${clef === 'bass' ? 'Acoustic Bass' : 'Piano'}</instrument-name>
      </score-instrument>
    </score-part>
  </part-list>
  <part id="P1">
${measuresXML}
  </part>
</score-partwise>`;
            
            return musicXML;
        }
        
        function generateMeasureXML(measureContent, measureNumber, clef, tempo) {
            const tokens = measureContent.split(/\s+/);
            let notesXML = '';
            let divisions = 4; // 16th notes per quarter note
            
            // Add attributes for first measure
            const clefSign = clef === 'bass' ? 'F' : 'G';
            const clefLine = clef === 'bass' ? '4' : '2';
            const attributes = measureNumber === 1 ? `
      <attributes>
        <divisions>4</divisions>
        <key>
          <fifths>0</fifths>
        </key>
        <time>
          <beats>4</beats>
          <beat-type>4</beat-type>
        </time>
        <clef>
          <sign>${clefSign}</sign>
          <line>${clefLine}</line>
        </clef>
      </attributes>
      <direction placement="above">
        <direction-type>
          <metronome>
            <beat-unit>quarter</beat-unit>
            <per-minute>${tempo}</per-minute>
          </metronome>
        </direction-type>
        <sound tempo="${tempo}"/>
      </direction>` : '';
            
            tokens.forEach(token => {
                notesXML += parseTokenToMusicXML(token);
            });
            
            return `    <measure number="${measureNumber}">${attributes}
${notesXML}
    </measure>
`;
        }
        
        function parseTokenToMusicXML(token) {
            let xml = '';
            let i = 0;
            
            while (i < token.length) {
                const char = token[i];
                
                if (char === 'z') {
                    // Rest
                    let duration = 1;
                    if (i + 1 < token.length && /[0-9]/.test(token[i + 1])) {
                        duration = parseInt(token[i + 1]);
                        i += 2;
                    } else {
                        i += 1;
                    }
                    
                    // Check if dotted
                    const isDotted = (duration === 3);
                    const baseDuration = isDotted ? 2 : duration;
                    
                    xml += `      <note>
        <rest/>
        <duration>${duration}</duration>
        <type>${getDurationType(baseDuration)}</type>
${isDotted ? '        <dot/>\n' : ''}      </note>
`;
                } else if (/[A-G]/.test(char)) {
                    // Note
                    let pitch = char;
                    let octave = 4; // Base octave
                    
                    i++; // Move past note letter
                    
                    // Count commas (lower octave) or apostrophes (higher octave)
                    let commaCount = 0;
                    let apostropheCount = 0;
                    while (i < token.length && (token[i] === ',' || token[i] === "'")) {
                        if (token[i] === ',') {
                            commaCount++;
                        } else {
                            apostropheCount++;
                        }
                        i++;
                    }
                    
                    // Check for lowercase (means upper octave in ABC)
                    const isLower = pitch === pitch.toLowerCase();
                    if (isLower) {
                        pitch = pitch.toUpperCase();
                        octave = 5;
                    }
                    
                    octave -= commaCount;
                    octave += apostropheCount;
                    
                    let duration = 1;
                    if (i < token.length && /[0-9]/.test(token[i])) {
                        duration = parseInt(token[i]);
                        i += 1;
                    }
                    
                    // Check for accidentals (^ for sharp, _ for flat)
                    let alter = 0;
                    if (token[i-1] === '^') {
                        alter = 1; // Sharp
                    } else if (token[i-1] === '_') {
                        alter = -1; // Flat
                    }
                    
                    // Check if dotted
                    const isDotted = (duration === 3);
                    const baseDuration = isDotted ? 2 : duration;
                    
                    xml += `      <note>
        <pitch>
          <step>${pitch}</step>
${alter !== 0 ? `          <alter>${alter}</alter>\n` : ''}          <octave>${octave}</octave>
        </pitch>
        <duration>${duration}</duration>
        <type>${getDurationType(baseDuration)}</type>
${isDotted ? '        <dot/>\n' : ''}      </note>
`;
                } else if (char === '^' || char === '_') {
                    // Accidental marker - skip, handled with note
                    i++;
                } else {
                    i++;
                }
            }
            
            return xml;
        }
        
        function getDurationType(duration) {
            switch(duration) {
                case 1: return '16th';
                case 2: return 'eighth';
                case 4: return 'quarter';
                case 8: return 'half';
                case 16: return 'whole';
                default: return '16th';
            }
        }
        
        // Wait for DOM to be fully loaded
        window.addEventListener('DOMContentLoaded', function() {
            generateArpeggio();
        });
    </script>
</body>
</html>